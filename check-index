#!/usr/bin/env python3

import argparse
import json
import sys
import yaml


RED = '\033[91m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
BLUE = '\033[94m'
RESET = '\033[0m'
UNDERLINE = '\033[4m'


class IndexValidator:
    def __init__(self, index):
        self.index = index
        self.item_types = list(index.keys())
        self.one_scenario_per_file = False
        self.errors = 0

    def error(self, msg):
        print(msg, file=sys.stderr)
        self.errors += 1

    def all_items(self):
        for item_type, items in sorted(self.index.items()):
            for item_key, item in sorted(items.items()):
                yield item_type, item_key, item

    def all_subitems(self, collection_key, collection):
        for item_type in sorted(self.item_types):
            subitems = collection.get(item_type)
            if subitems is None:
                continue
            if not subitems:
                self.error(f"Collection {GREEN}{collection_key}{RESET} has empty subitem list for {RED}{item_type}{RESET}")
                continue
            for subitem_key in sorted(subitems):
                yield item_type, subitem_key, self.index[item_type].get(subitem_key)

    def validate_scenario(self, scenario_key, scenario, content_path, content):
        docs = []
        try:
            for doc in yaml.safe_load_all(content):
                docs += [doc]
        except yaml.YAMLError as e:
            self.error(f"Error parsing YAML in {RED}{content_path}{RESET}: {e}")
            return
        except Exception as e:
            self.error(f"Error parsing YAML in {RED}{content_path}{RESET}: {e}")
            return

        num_docs = 0
        names = []
        found = False
        for doc in docs:
            num_docs += 1
            name = doc.get('name')
            if name is None:
                self.error(f"Scenario {GREEN}{scenario_key}{RESET} has {RED}document without name{RESET} in {content_path}")
                continue
            names += [name]
            if name == scenario_key:
                found = True

        if num_docs > 1 and self.one_scenario_per_file:
            self.error(f"Scenario {GREEN}{scenario_key}{RESET} has more than one document: {RED}{', '.join(names)}{RESET} in {content_path}")

        if not found:
            self.error(f"Scenario file {RED}{content_path}{RESET} does not have a document named {GREEN}{scenario_key}{RESET}")

    def validate(self):
        for item_type, item_key, item in self.all_items():

            # the item must have the "author" field
            author = item.get('author')
            if author is None:
                self.error(f"Item {GREEN}{item_type}:{item_key}{RESET} is missing author")
                continue

            # the key prefix and the author must match
            if not item_key.startswith(f"{author}/"):
                self.error(f"Item {GREEN}{item_type}:{item_key}{RESET} does not start with author {author}")

            # the item must have the "path" field
            pth = item.get('path')
            if pth is None:
                self.error(f"Item {GREEN}{item_type}:{item_key}{RESET} is missing path")
                continue

            # item's path must reference the expected location, based on the item type and stage
            stage = item.get('stage')
            basedir = f"{item_type}/{stage}" if stage else item_type
            expected_paths = [
                f"{basedir}/{item_key}.yml",
                f"{basedir}/{item_key}.yaml"
            ]
            if pth not in expected_paths:
                self.error(f"Item {GREEN}{item_type}:{item_key}{RESET} has unexpected path {RED}{pth}{RESET}")

            # the item's file must exist in the repo
            try:
                with open(pth, 'r') as f:
                    if item_type == 'scenarios':
                        self.validate_scenario(item_key, item, pth, f.read())
            except FileNotFoundError:
                self.error(f"Item {GREEN}{item_type}:{item_key}{RESET} file {RED}{pth}{RESET} does not exist")

            # if it's a collection, check that its sub-items exist
            if item_type == 'collections':
                for subitem_type, subitem_key, subitem in self.all_subitems(item_key, item):
                    if subitem is None:
                        self.error(f"{GREEN}{item_type}:{item_key}{RESET} references missing subitem {RED}{subitem_type}:{subitem_key}{RESET}")


def main(argv):
    parser = argparse.ArgumentParser(description='Validate items in the index file')
    parser.add_argument('index_file', help='The index file to validate')
    parser.add_argument('--one-scenario-per-file', action='store_true',
                        help='Check for multiple documents in a scenario file')

    args = parser.parse_args()

    print(f"Validating index file: {args.index_file}", file=sys.stderr)

    try:
        with open(args.index_file, 'r') as file:
            index = json.load(file)
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        # print to stderr
        print(f"File not found: {args.index_file}", file=sys.stderr)
        sys.exit(1)

    validator = IndexValidator(index)
    if args.one_scenario_per_file:
        validator.one_scenario_per_file = True
    validator.validate()

    tot_items = len(list(validator.all_items()))
    print(f"Validated {tot_items} items, {validator.errors} errors", file=sys.stderr)

    if validator.errors > 0:
        sys.exit(1)


if __name__ == "__main__":
    main(sys.argv)
